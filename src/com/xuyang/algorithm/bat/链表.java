package com.xuyang.algorithm.bat;

/**
 * @Auther: allanyang
 * @Date: 2020/1/12 17:39
 * @Description:
 **/
public class 链表 {

    // 1.给定一个整数num，如何在节点值有序的环形链表中插入一个值为num的节点，并且保证这个环形单链表依然有序。
    /**
     * 1.链表为null
     * 2.链表中间节点
     * 3.链表初始节点（此时返回的是新插入的那个节点）
     * 4.链表结束节点
     */

    // 2.给定一个链表的头节点head，在给定一个数num，请把链表调节成节点小于num的节点都放在哦链表左边，值等于num的节点都放在链表中间，值大于num的节点都放在链表右边。
    /**
     * 1。用数组，partition来做
     * 2.遍历一次链表，分别组成小于num,等于num，大于num组成的链表。然后在把链表合成一个链表
     */

    // 3.给定两个有序链表的头节点head1和head2，打印两个有序链表的公共部分。
    /**
     * 两个链表同时移动，哪个小哪个向前移动一步
     */

    // 4.给定一个链表节点head，实现一个调用单链表的函数，使得每k个节点之间逆序，如果最后不够k个系欸但那，则不调整最后几个节点。
    /**
     * leetcode 25
     */

    // 5.给定一个单链表头节点head，链表中每个节点保存一个整数，在给定一个值value，把所有等于val的节点删掉。
    /**
     * 相当于构造链表节点，遍历一次链表，等于value的时候过滤掉，反之进行构造链表操作。
     */

    // 6.链表是否有环
    /**
     * 1.hash表
     * 2.快慢指针
     */

    // 7.两个链表是否相交
    /**
     * 1.计算两个链表长度，如果一个100，一个50，则让100的先走50步，然后同步走。判断是否相等
     *
     * 2.两个链表同时走，当一个走到为节点后，会从另一个节点的头节点再走。如果相交则在第二次相撞（和第一个思想是一样的）
     */
}
